<!doctype html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>deception-ai UI</title>
    <style>
      :root {
        --bg: #0b0f17;
        --panel: #121a2a;
        --panel2: #0f1523;
        --text: #e7eefc;
        --muted: #91a4c6;
        --border: #25304a;
        --accent: #7aa2ff;
        --danger: #ff6b6b;
        --info: #7cc7ff; /* witness */
      }
      html,
      body {
        margin: 0;
        padding: 0;
        height: 100%;
        background: var(--bg);
        color: var(--text);
        font-family: system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial, sans-serif;
      }

      input,
      button,
      textarea,
      select {
        font: inherit;
        background: var(--panel2);
        color: var(--text);
        border: 1px solid var(--border);
        border-radius: 8px;
        padding: 10px;
      }
      button {
        cursor: pointer;
      }
      button.primary {
        background: var(--accent);
        border-color: transparent;
        color: #071026;
        font-weight: 600;
      }

      button:disabled {
        opacity: 0.65;
        cursor: not-allowed;
      }

      /* Pressed/running state for async actions */
      button.pressed {
        background: rgba(122, 162, 255, 0.22);
        border-color: rgba(122, 162, 255, 0.65);
        box-shadow: inset 0 0 0 2px rgba(122, 162, 255, 0.18);
        color: var(--text);
      }

      .wrap {
        max-width: 1400px;
        margin: 0 auto;
        padding: 20px;
      }
      .row {
        display: flex;
        gap: 12px;
        flex-wrap: wrap;
        align-items: center;
      }
      .card {
        background: var(--panel);
        border: 1px solid var(--border);
        border-radius: 12px;
        padding: 14px;
      }
      .muted {
        color: var(--muted);
      }
      .error {
        color: var(--danger);
      }
      .title {
        display: flex;
        align-items: baseline;
        justify-content: space-between;
        gap: 12px;
      }
      .title h1 {
        margin: 0;
        font-size: 18px;
      }
      .title small {
        color: var(--muted);
      }

      /* New layout requested */
      .board {
        display: grid;
        grid-template-columns: 1fr 1fr;
        gap: 12px;
        align-items: start;
      }
      .leftCol {
        display: grid;
        grid-template-rows: auto 1fr;
        gap: 12px;
        min-height: 720px;
      }
      .rightCol {
        min-height: 720px;
        max-height: 80vh;
        overflow: auto;
      }

      @media (max-width: 980px) {
        .board {
          grid-template-columns: 1fr;
        }
        .leftCol,
        .rightCol {
          min-height: auto;
          max-height: none;
        }
      }

      .player {
        margin-bottom: 12px;
      }
      .player header {
        display: flex;
        justify-content: space-between;
        align-items: baseline;
        gap: 10px;
        margin-bottom: 8px;
      }
      .pill {
        font-size: 12px;
        padding: 2px 8px;
        border-radius: 999px;
        background: rgba(122, 162, 255, 0.15);
        border: 1px solid rgba(122, 162, 255, 0.3);
        color: var(--accent);
        white-space: nowrap;
      }
      .hand {
        display: grid;
        grid-template-columns: 1fr;
        gap: 6px;
      }
      .hand .line {
        display: flex;
        gap: 8px;
        flex-wrap: wrap;
      }

      .tag {
        font-size: 12px;
        padding: 2px 8px;
        border-radius: 999px;
        background: rgba(145, 164, 198, 0.10);
        border: 1px solid rgba(145, 164, 198, 0.25);
        color: var(--text);
      }

      /* Make selections much more obvious */
      .tag.selected {
        background: rgba(122, 162, 255, 0.42);
        border-color: rgba(122, 162, 255, 0.95);
        box-shadow: 0 0 0 2px rgba(122, 162, 255, 0.18);
        color: #ffffff;
        font-weight: 650;
      }

      /* Role highlighting chips */
      .roleTag {
        display: inline-block;
        font-size: 12px;
        padding: 2px 8px;
        border-radius: 999px;
        background: rgba(145, 164, 198, 0.10);
        border: 1px solid rgba(145, 164, 198, 0.25);
        color: var(--text);
        white-space: nowrap;
      }
      .roleTag.unknown {
        color: var(--muted);
        border-style: dashed;
      }
      .roleTag.danger {
        background: rgba(255, 107, 107, 0.18);
        border-color: rgba(255, 107, 107, 0.55);
        color: #ffd2d2;
      }
      .roleTag.witness {
        background: rgba(124, 199, 255, 0.16);
        border-color: rgba(124, 199, 255, 0.45);
        color: #d7f1ff;
      }

      .discussion {
        min-height: 560px;
        display: flex;
        flex-direction: column;
      }
      .log {
        flex: 1;
        overflow: auto;
        border: 1px solid var(--border);
        border-radius: 10px;
        padding: 10px;
        background: rgba(0, 0, 0, 0.15);
      }
      .msg {
        padding: 8px 10px;
        border-bottom: 1px solid rgba(37, 48, 74, 0.6);
      }
      .msg:last-child {
        border-bottom: 0;
      }
      .msg .meta {
        font-size: 12px;
        color: var(--muted);
        display: flex;
        justify-content: space-between;
        gap: 10px;
      }
      .composer {
        display: flex;
        gap: 10px;
        margin-top: 10px;
      }
      .composer textarea {
        flex: 1;
        min-height: 60px;
        resize: vertical;
      }

      /* Embedded scene picker + display */
      .scenePicker {
        display: grid;
        grid-template-columns: 1fr;
        gap: 10px;
        margin-top: 8px;
      }
      .scenePicker .tags {
        display: flex;
        flex-wrap: wrap;
        gap: 8px;
        margin-top: 8px;
      }
      .scenePicker .tagBtn {
        cursor: pointer;
        user-select: none;
      }
      .scenePicker .tagBtn.selected {
        background: rgba(122, 162, 255, 0.25);
        border-color: rgba(122, 162, 255, 0.8);
      }

      .sceneCards {
        display: grid;
        grid-template-columns: 1fr;
        gap: 8px;
        margin-top: 10px;
      }
      .sceneCard {
        background: rgba(0, 0, 0, 0.12);
      }
    </style>
  </head>
  <body>
    <div class="wrap" id="app"></div>

    <script>
      const app = document.getElementById('app');

      const API_BASE = (() => window.__API_BASE__ || '')();

      function qs(sel) {
        return document.querySelector(sel);
      }

      function el(tag, attrs = {}, children = []) {
        const node = document.createElement(tag);
        for (const [k, v] of Object.entries(attrs)) {
          if (k === 'class') node.className = v;
          else if (k === 'text') node.textContent = v;
          else if (k === 'html') node.innerHTML = v;
          else if (k === 'style') node.setAttribute('style', v);
          else if (k.startsWith('on') && typeof v === 'function') node.addEventListener(k.slice(2).toLowerCase(), v);
          else if (v !== undefined && v !== null) node.setAttribute(k, v);
        }
        for (const c of children) node.appendChild(typeof c === 'string' ? document.createTextNode(c) : c);
        return node;
      }

      async function api(path, opts = {}) {
        const res = await fetch(API_BASE + path, {
          headers: { 'Content-Type': 'application/json', ...(opts.headers || {}) },
          ...opts,
        });
        if (!res.ok) {
          const text = await res.text();
          throw new Error(text || 'HTTP ' + res.status);
        }
        return res.json();
      }

      function formatRole(role) {
        return role.replaceAll('_', ' ');
      }

      // POV (view perspective)
      function povLabel(pov) {
        if (pov === 'fs') return 'Forensic Scientist';
        if (pov === 'murderer') return 'Murderer';
        if (pov === 'witness') return 'Witness';
        if (pov === 'investigator') return 'Investigator';
        return 'Forensic Scientist';
      }

      function getPov() {
        return (window.__POV__ || localStorage.getItem('deception:pov') || 'fs');
      }

      function setPov(pov) {
        window.__POV__ = pov;
        localStorage.setItem('deception:pov', pov);
      }

      function canSeeMurdererRoles(pov) {
        return pov === 'fs' || pov === 'murderer' || pov === 'witness';
      }

      function canSeeMurderSelections(pov) {
        return pov === 'fs' || pov === 'murderer' || pov === 'accomplice';
      }

      function route() {
        const h = window.location.hash || '#/';
        const parts = h.replace('#', '').split('/').filter(Boolean);
        if (parts.length === 0) return { name: 'home' };
        if (parts[0] === 'game' && parts[1]) return { name: 'game', gameId: parts[1] };
        return { name: 'home' };
      }

      function navigate(hash) {
        window.location.hash = hash;
      }

      function renderHome() {
        app.innerHTML = '';

        const join = el('div', { class: 'card' }, [
          el('div', { class: 'title' }, [
            el('h1', { text: 'deception-ai' }),
            el('small', { class: 'muted', text: 'Minimal local UI (websocket updates)' }),
          ]),
          el('p', { class: 'muted', text: 'Join an existing game by ID, or create a new one.' }),
        ]);

        const joinRow = el('div', { class: 'row' }, [
          el('input', { id: 'joinGameId', placeholder: 'game id (UUID)', style: 'min-width: 340px' }),
          el('button', {
            class: 'primary',
            text: 'Join',
            onclick: () => {
              const id = qs('#joinGameId').value.trim();
              if (!id) return;
              navigate(`#/game/${id}`);
            },
          }),
        ]);

        const createCard = el('div', { class: 'card', style: 'margin-top: 12px' }, [
          el('div', { class: 'title' }, [
            el('h1', { text: 'Create new game' }),
            el('small', { class: 'muted', text: '4–12 total players supported by rules' }),
          ]),
          el('div', { class: 'row', style: 'margin-top: 10px' }, [
            el('label', { class: 'muted', text: 'AI players' }),
            el('input', { id: 'numAi', type: 'number', min: '0', max: '12', value: '4', style: 'width: 90px' }),
            el('label', { class: 'muted', text: 'Human players' }),
            el('input', { id: 'numHuman', type: 'number', min: '0', max: '12', value: '0', style: 'width: 90px' }),
            el('button', {
              class: 'primary',
              text: 'Create',
              onclick: async () => {
                const num_ai_players = parseInt(qs('#numAi').value, 10);
                const num_human_players = parseInt(qs('#numHuman').value, 10);
                const err = qs('#homeErr');
                err.textContent = '';
                try {
                  const state = await api('/game', {
                    method: 'POST',
                    body: JSON.stringify({ num_ai_players, num_human_players }),
                  });
                  navigate(`#/game/${state.game_id}`);
                } catch (e) {
                  err.textContent = e.message;
                }
              },
            }),
          ]),
          el('div', { id: 'homeErr', class: 'error', style: 'margin-top: 10px' }),
        ]);

        join.appendChild(joinRow);
        app.appendChild(join);
        app.appendChild(createCard);
      }

      async function loadCardNameMaps() {
        const assetsRoot = '/ui-assets';
        const [meansCsv, clueCsv, lcdCsv, sceneCsv] = await Promise.all([
          fetch(assetsRoot + '/means_cards.csv').then((r) => r.text()),
          fetch(assetsRoot + '/clue_cards.csv').then((r) => r.text()),
          fetch(assetsRoot + '/location_and_cause_of_death_tiles.csv').then((r) => r.text()),
          fetch(assetsRoot + '/scene_tiles.csv').then((r) => r.text()),
        ]);

        function parseCsv(text) {
          const lines = text.split(/\r?\n/).filter((l) => l.trim().length);
          const out = new Map();
          for (let i = 1; i < lines.length; i++) {
            const row = lines[i];
            const idx = row.indexOf(',');
            if (idx === -1) continue;
            const id = row.slice(0, idx).trim();
            let name = row.slice(idx + 1).trim();
            if (name.startsWith('"') && name.endsWith('"')) name = name.slice(1, -1);
            if (id) out.set(id, name || id);
          }
          return out;
        }

        function parseTileOptionsCsv(text) {
          // Expected columns: id,tile,option (with optional quoting)
          const lines = text.split(/\r?\n/).filter((l) => l.trim().length);
          const byId = new Map();
          const optionsByTile = new Map();

          function splitRow(row) {
            const out = [];
            let cur = '';
            let inQ = false;
            for (let i = 0; i < row.length; i++) {
              const ch = row[i];
              if (ch === '"') {
                inQ = !inQ;
                continue;
              }
              if (ch === ',' && !inQ) {
                out.push(cur.trim());
                cur = '';
                continue;
              }
              cur += ch;
            }
            out.push(cur.trim());
            return out;
          }

          for (let i = 1; i < lines.length; i++) {
            const cols = splitRow(lines[i]);
            if (cols.length < 3) continue;
            const id = cols[0];
            const tile = cols[1];
            const option = cols[2];
            if (!tile || !option) continue;

            if (id) byId.set(id, { tile, option });
            if (!optionsByTile.has(tile)) optionsByTile.set(tile, []);
            optionsByTile.get(tile).push({ id: id || option, option });
          }

          for (const [tile, opts] of optionsByTile.entries()) {
            opts.sort((a, b) => String(a.option).localeCompare(String(b.option)));
            optionsByTile.set(tile, opts);
          }

          return { byId, optionsByTile };
        }

        return {
          means: parseCsv(meansCsv),
          clues: parseCsv(clueCsv),
          lcd: parseTileOptionsCsv(lcdCsv),
          scene: parseTileOptionsCsv(sceneCsv),
        };
      }

      function chipsRow(opts, selectedIdOrOption, { clickable = false, onPick = null } = {}) {
        const row = el('div', { class: 'tags' });
        if (!opts || !opts.length) {
          row.appendChild(el('span', { class: 'muted', text: '—' }));
          return row;
        }
        for (const o of opts) {
          const cls = ['tag'];
          const match = selectedIdOrOption && (o.id === selectedIdOrOption || o.option === selectedIdOrOption);
          if (match) cls.push('selected');

          if (clickable) {
            cls.push('tagBtn');
            row.appendChild(
              el('button', {
                class: cls.join(' '),
                title: o.id,
                text: o.option,
                onclick: () => onPick && onPick(o.id, o.option),
              }),
            );
          } else {
            row.appendChild(el('span', { class: cls.join(' '), title: o.id, text: o.option }));
          }
        }
        return row;
      }

      function renderSceneCompact(state, cardNames) {
        const locId = state?.fs_location_id || null;
        const causeId = state?.fs_cause_id || null;

        const lcd = cardNames?.lcd;
        const lcdById = lcd?.byId || null;

        const locTile = state?.fs_location_tile || (locId && lcdById?.get(locId)?.tile) || null;
        const causeTile = state?.fs_cause_tile || (causeId && lcdById?.get(causeId)?.tile) || null;

        const locOpts = (locTile && lcd?.optionsByTile?.get(locTile)) || [];
        const causeOpts = (causeTile && lcd?.optionsByTile?.get(causeTile)) || [];

        return el('div', { class: 'card', style: 'background: var(--panel2); margin-top: 8px' }, [
          el('div', { style: 'font-weight: 650; margin-bottom: 6px', text: 'Scene' }),

          // Only show tile names (no "Location tile:" / "Cause tile:" prefix)
          el('div', { style: 'font-weight: 600; margin-top: 2px', text: locTile || '—' }),
          chipsRow(locOpts, locId),

          el('div', { style: 'font-weight: 600; margin-top: 10px', text: causeTile || '—' }),
          chipsRow(causeOpts, causeId),
        ]);
      }

      function renderFsScenePicker(state, cardNames, playerId) {
        const lcd = cardNames?.lcd;
        const locTile = state?.fs_location_tile || null;
        const causeTile = state?.fs_cause_tile || null;

        const locOpts = (locTile && lcd?.optionsByTile?.get(locTile)) || [];
        const causeOpts = (causeTile && lcd?.optionsByTile?.get(causeTile)) || [];

        let selLoc = state?.fs_location_id || null;
        let selCause = state?.fs_cause_id || null;

        const errLine = el('div', { class: 'error', style: 'margin-top: 6px' });

        function mkTileBlock(title, tile, opts, current, setCurrent) {
          const header = el('div', { class: 'line' }, [
            // Show only the tile name (no "Location:" / "Cause of Death:" label)
            el('span', { style: 'font-weight: 600', text: tile || '—' }),
          ]);

          const tags = el('div', { class: 'tags' });
          if (!tile) {
            tags.appendChild(el('span', { class: 'muted', text: 'Waiting for dealt tile…' }));
          } else if (!opts || !opts.length) {
            tags.appendChild(el('span', { class: 'muted', text: 'No options found for tile.' }));
          } else {
            for (const o of opts) {
              const cls = ['tag', 'tagBtn'];
              if (current && o.id === current) cls.push('selected');
              tags.appendChild(
                el('button', {
                  class: cls.join(' '),
                  text: o.option,
                  title: o.id,
                  onclick: () => {
                    setCurrent(o.id);
                    const evt = new CustomEvent('deception:fs_scene_local_change');
                    window.dispatchEvent(evt);
                  },
                }),
              );
            }
          }

          return el('div', { class: 'card', style: 'background: var(--panel2); border-style: dashed;' }, [
            el('div', { style: 'font-weight: 650; margin-bottom: 6px', text: 'Pick ' + title }),
            header,
            tags,
          ]);
        }

        const pickBtn = el('button', {
          class: 'primary',
          text: 'Confirm scene',
          onclick: async () => {
            errLine.textContent = '';
            if (!selLoc || !selCause) {
              errLine.textContent = 'Pick both a Location and a Cause of Death.';
              return;
            }
            try {
              await api(`/game/${state.game_id}/player/${encodeURIComponent(playerId)}/fs_scene`, {
                method: 'POST',
                body: JSON.stringify({ location: selLoc, cause: selCause }),
              });
            } catch (e) {
              errLine.textContent = e.message;
            }
          },
        });

        const outer = el('div', { class: 'scenePicker' }, [el('div', { class: 'muted', text: 'Set the scene (FS only)' })]);

        outer.appendChild(mkTileBlock('Location', locTile, locOpts, selLoc, (v) => (selLoc = v)));
        outer.appendChild(mkTileBlock('Cause of Death', causeTile, causeOpts, selCause, (v) => (selCause = v)));
        outer.appendChild(el('div', { class: 'row' }, [pickBtn]));
        outer.appendChild(errLine);

        window.addEventListener(
          'deception:fs_scene_local_change',
          () => {
            const mount = qs('#fsSceneInnerMount');
            if (!mount) return;
            mount.innerHTML = '';
            mount.appendChild(renderFsScenePicker({ ...state, fs_location_id: selLoc, fs_cause_id: selCause }, cardNames, playerId));
          },
          { once: true },
        );

        return el('div', { id: 'fsSceneInnerMount' }, [outer]);
      }

      function renderFsSceneBulletsCompact(state, cardNames) {
        const tiles = (state?.fs_scene_tiles || []).slice(0, 4);
        const picks = state?.fs_scene_bullets || {};
        const scene = cardNames?.scene;

        const wrap = el('div', { class: 'card', style: 'background: var(--panel2); margin-top: 10px' }, [
          el('div', { style: 'font-weight: 650; margin-bottom: 6px', text: 'Scene tiles' }),
        ]);

        if (!tiles.length) {
          wrap.appendChild(el('div', { class: 'muted', text: 'Waiting for dealt scene tiles…' }));
          return wrap;
        }

        const cards = el('div', { class: 'sceneCards' });
        for (const tile of tiles) {
          const opts = (tile && scene?.optionsByTile?.get(tile)) || [];
          const selected = picks[tile] || null;

          const c = el('div', { class: 'card sceneCard' }, [
            // Only show the tile name (no "Tile:" label)
            el('div', { style: 'font-weight: 600', text: tile || '—' }),
            chipsRow(opts, selected),
          ]);

          cards.appendChild(c);
        }

        wrap.appendChild(cards);
        return wrap;
      }

      function renderFsPanel(state, cardNames) {
        const players = (state.players || []).slice().sort((a, b) => a.seat - b.seat);
        const fs = players.find((p) => p.role === 'forensic_scientist');
        const fsId = fs?.player_id || null;

        return el('div', { class: 'card' }, [
          el('div', { class: 'title' }, [
            el('h1', { text: 'Forensic Scientist' }),
            el('small', { class: 'muted', text: `phase: ${state.phase}` }),
          ]),

          // Always show these as chip cards
          state.phase === 'setup_awaiting_fs_scene_pick' && fsId
            ? renderFsScenePicker(state, cardNames, fsId)
            : renderSceneCompact(state, cardNames),

          // Also show the 4 scene tiles + selected bullet chips when available
          renderFsSceneBulletsCompact(state, cardNames),
        ]);
      }

      function renderPlayer(p, cardNames, state) {
        const pov = getPov();
        const isFs = p.role === 'forensic_scientist';

        let roleText = 'unknown';
        if (isFs || pov === 'fs') roleText = formatRole(p.role);
        else if (canSeeMurdererRoles(pov) && (p.role === 'murderer' || p.role === 'accomplice')) roleText = formatRole(p.role);

        const display = p.display_name || p.player_id;

        const roleCls = ['roleTag'];
        if (roleText === 'unknown') roleCls.push('unknown');
        if (p.role === 'murderer' || p.role === 'accomplice') {
          // highlight these identities in red when the POV can know them
          if (canSeeMurdererRoles(pov)) roleCls.push('danger');
        }
        if (p.role === 'witness') {
          // witness highlight (FS always sees)
          if (pov === 'fs') roleCls.push('witness');
        }

        const header = el('header', {}, [
          el('div', {}, [
            el('div', { text: display, style: 'font-weight: 600' }),
            el('div', { class: 'muted' }, [el('span', { class: roleCls.join(' '), text: roleText })]),
          ]),
          el('span', { class: 'pill', text: p.is_ai ? 'AI' : 'Human' }),
        ]);

        // Show cards for everyone, but only highlight murderer selections when allowed.
        const selectedMeans = canSeeMurderSelections(pov) ? state?.solution?.means_id || null : null;
        const selectedClue = canSeeMurderSelections(pov) ? state?.solution?.clue_id || null : null;

        const means = el('div', { class: 'line' }, [el('span', { class: 'muted', text: 'Means:' })]);
        for (const id of (p.hand?.means_ids || [])) {
          const name = cardNames?.means?.get(id) || id;
          const cls = ['tag'];
          if (selectedMeans && id === selectedMeans && p.role === 'murderer') cls.push('selected');
          means.appendChild(el('span', { class: cls.join(' '), 'data-id': id, title: id, text: name }));
        }

        const clues = el('div', { class: 'line' }, [el('span', { class: 'muted', text: 'Clues:' })]);
        for (const id of (p.hand?.clue_ids || [])) {
          const name = cardNames?.clues?.get(id) || id;
          const cls = ['tag'];
          if (selectedClue && id === selectedClue && p.role === 'murderer') cls.push('selected');
          clues.appendChild(el('span', { class: cls.join(' '), 'data-id': id, title: id, text: name }));
        }

        return el('div', { class: 'card player' }, [header, el('div', { class: 'hand' }, [means, clues])]);
      }

      function renderPlayersColumn(state, cardNames) {
        const players = (state.players || []).slice().sort((a, b) => a.seat - b.seat);
        const fs = players.find((p) => p.role === 'forensic_scientist');
        const others = players.filter((p) => p !== fs);

        const col = el('div');
        for (const p of others) {
          col.appendChild(renderPlayer(p, cardNames, state));
        }
        return col;
      }

      function renderDiscussion(state, playerId) {
        const log = el('div', { class: 'log', id: 'log' });
        const byId = new Map((state.players || []).map((p) => [p.player_id, p]));
        for (const m of state.discussion || []) {
          const p = byId.get(m.player_id);
          const name = p?.display_name || m.player_id;
          const meta = el('div', { class: 'meta' }, [
            el('span', { text: name }),
            el('span', { text: new Date(m.created_at).toLocaleString() }),
          ]);
          log.appendChild(el('div', { class: 'msg' }, [meta, el('div', { text: m.comments })]));
        }

        const textarea = el('textarea', { id: 'commentBox', placeholder: 'Say something to the table…' });
        const sendBtn = el('button', {
          class: 'primary',
          text: 'Send',
          onclick: async () => {
            const text = textarea.value.trim();
            if (!text) return;
            const err = qs('#gameErr');
            err.textContent = '';
            try {
              await api(`/game/${state.game_id}/player/${encodeURIComponent(playerId)}/discuss`, {
                method: 'POST',
                body: JSON.stringify({ comments: text }),
              });
              textarea.value = '';
            } catch (e) {
              err.textContent = e.message;
            }
          },
        });

        return el('div', { class: 'card discussion' }, [
          el('div', { class: 'title' }, [
            el('h1', { text: 'Discussion' }),
            el('small', { class: 'muted', text: `phase: ${state.phase}` }),
          ]),
          log,
          el('div', { class: 'composer' }, [textarea, sendBtn]),
        ]);
      }

      async function renderGame(gameId) {
        app.innerHTML = '';

        // Local UI state for this view.
        let isRunAgentsPending = false;
        let runAgentsBtn = null;

        function syncRunAgentsBtn() {
          if (!runAgentsBtn) return;
          runAgentsBtn.disabled = isRunAgentsPending;
          runAgentsBtn.classList.toggle('pressed', isRunAgentsPending);
          runAgentsBtn.setAttribute('aria-pressed', String(isRunAgentsPending));
          runAgentsBtn.setAttribute('aria-busy', String(isRunAgentsPending));
          runAgentsBtn.textContent = isRunAgentsPending ? 'Running AI agents…' : 'Run AI agents once';
        }

        // View settings: POV selector (moved into header)
        const povSelect = (() => {
          const sel = el('select', { id: 'povSelect', style: 'min-width: 220px' }, [
            el('option', { value: 'fs', text: 'Forensic Scientist' }),
            el('option', { value: 'murderer', text: 'Murderer' }),
            el('option', { value: 'witness', text: 'Witness' }),
            el('option', { value: 'investigator', text: 'Investigator' }),
          ]);
          sel.value = getPov();
          sel.addEventListener('change', () => {
            setPov(sel.value);
            window.dispatchEvent(new CustomEvent('deception:pov_changed'));
          });
          return sel;
        })();

        // Gameplay page header
        const header = el('div', { class: 'card', style: 'margin-bottom: 12px; padding: 12px 14px' }, [
          el('div', { class: 'row' }, [
            el('div', { style: 'font-size: 18px; font-weight: 750', text: 'Deception: AI' }),
            el('div', { style: 'flex: 1' }),
            el('label', { class: 'muted', text: 'POV' }),
            povSelect,
          ]),
          el('div', { id: 'gameErr', class: 'error', style: 'margin-top: 10px' }),
        ]);

        const top = el('div', { class: 'row', style: 'margin-bottom: 12px' }, [
          el('button', { text: '← Home', onclick: () => navigate('#/') }),
          el('div', { class: 'muted', text: 'Game:' }),
          el('div', { style: 'font-weight: 600', text: gameId }),
          el('div', { style: 'flex: 1' }),
          (() => {
            runAgentsBtn = el('button', {
              text: 'Run AI agents once',
              onclick: async () => {
                // Guard against double clicks.
                if (isRunAgentsPending) return;

                const err = qs('#gameErr');
                err.textContent = '';

                isRunAgentsPending = true;
                syncRunAgentsBtn();

                try {
                  await api(`/games/${gameId}/agents/run_once?block_ms=10&count=10`, { method: 'POST' });
                } catch (e) {
                  err.textContent = e.message;
                } finally {
                  // If the view is still mounted, clear the pressed state.
                  // (Rerenders from websocket/poll will also clear it.)
                  isRunAgentsPending = false;
                  syncRunAgentsBtn();
                }
              },
            });
            runAgentsBtn.setAttribute('aria-pressed', 'false');
            runAgentsBtn.setAttribute('aria-busy', 'false');
            return runAgentsBtn;
          })(),
        ]);

        const board = el('div', { class: 'board' }, [
          el('div', { class: 'leftCol' }, [el('div', { id: 'fsPanel' }), el('div', { id: 'chatPanel' })]),
          el('div', { class: 'rightCol', id: 'playersPanel' }),
        ]);

        app.appendChild(header);
        app.appendChild(top);
        app.appendChild(board);

        let state;
        try {
          state = await api(`/game/${gameId}`);
        } catch (e) {
          app.appendChild(el('div', { class: 'card error', text: e.message }));
          return;
        }

        let cardNames = null;
        try {
          cardNames = await loadCardNameMaps();
        } catch (e) {
          console.warn('Failed to load card name maps', e);
        }

        const fsDefault =
          state.players.find((p) => p.role === 'forensic_scientist')?.player_id || state.players[0]?.player_id || 'p1';

        function rerender(newState) {
          state = newState;

          // Any successful update means we're no longer waiting on the run-once call.
          if (isRunAgentsPending) {
            isRunAgentsPending = false;
            syncRunAgentsBtn();
          }

          // With “Post as player_id” removed, default to FS (or first player).
          const playerId = fsDefault;

          const fsPanel = qs('#fsPanel');
          if (fsPanel) {
            fsPanel.innerHTML = '';
            fsPanel.appendChild(renderFsPanel(state, cardNames));
          }

          const chatPanel = qs('#chatPanel');
          if (chatPanel) {
            chatPanel.innerHTML = '';
            chatPanel.appendChild(renderDiscussion(state, playerId));
          }

          const playersPanel = qs('#playersPanel');
          if (playersPanel) {
            playersPanel.innerHTML = '';
            playersPanel.appendChild(renderPlayersColumn(state, cardNames));
          }

          const log = qs('#log');
          if (log) log.scrollTop = log.scrollHeight;
        }

        rerender(state);

        // Rerender locally when POV changes (no refetch needed).
        const onPovChanged = () => rerender(state);
        window.addEventListener('deception:pov_changed', onPovChanged);

        // Re-layout on resize.
        let resizeTimer = null;
        window.addEventListener('resize', () => {
          if (resizeTimer) clearTimeout(resizeTimer);
          resizeTimer = setTimeout(() => rerender(state), 50);
        });

        // Live updates via websocket.
        const wsProto = window.location.protocol === 'https:' ? 'wss' : 'ws';
        const wsUrl = `${wsProto}://${window.location.host}/ws/game/${gameId}`;
        let ws;
        try {
          ws = new WebSocket(wsUrl);
        } catch (e) {
          console.warn('WebSocket failed to construct:', e);
        }

        let pollTimer = null;
        function startPollingFallback() {
          if (pollTimer) return;
          pollTimer = setInterval(async () => {
            try {
              const s = await api(`/game/${gameId}`);
              rerender(s);
            } catch (_) {}
          }, 1500);
        }

        if (ws) {
          ws.onopen = () => {
            setInterval(() => {
              if (ws.readyState === 1) ws.send('ping');
            }, 20000);
          };
          ws.onmessage = async (evt) => {
            try {
              const msg = JSON.parse(evt.data);
              if (msg.type === 'game_updated') {
                const s = await api(`/game/${gameId}`);
                rerender(s);
              }
            } catch (e) {
              console.warn('ws message parse failed', e);
            }
          };
          ws.onerror = () => startPollingFallback();
          ws.onclose = () => startPollingFallback();
          setTimeout(() => {
            if (ws.readyState !== 1) startPollingFallback();
          }, 1200);
        } else {
          startPollingFallback();
        }
      }

      async function render() {
        const r = route();
        if (r.name === 'home') return renderHome();
        if (r.name === 'game') return renderGame(r.gameId);
      }

      window.addEventListener('hashchange', render);
      render();
    </script>
  </body>
</html>
